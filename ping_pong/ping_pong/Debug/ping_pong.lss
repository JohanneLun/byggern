
ping_pong.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000052  00800100  00000964  000009f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000964  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000010  00800152  00800152  00000a4a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a4a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000238  00000000  00000000  00000a7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000018e3  00000000  00000000  00000cb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b93  00000000  00000000  00002595  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b52  00000000  00000000  00003128  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000053c  00000000  00000000  00003c7c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005f9  00000000  00000000  000041b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000d0f  00000000  00000000  000047b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001d0  00000000  00000000  000054c0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
   4:	0c 94 8a 01 	jmp	0x314	; 0x314 <__vector_1>
   8:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
   c:	0c 94 7b 00 	jmp	0xf6	; 0xf6 <__vector_3>
  10:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  14:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  18:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  1c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  20:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  24:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  28:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  2c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  30:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  34:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  38:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  3c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  40:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  44:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  48:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  4c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  50:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  54:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  58:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  5c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  60:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  64:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  68:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  6c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>

00000070 <__ctors_end>:
  70:	11 24       	eor	r1, r1
  72:	1f be       	out	0x3f, r1	; 63
  74:	cf ef       	ldi	r28, 0xFF	; 255
  76:	d4 e0       	ldi	r29, 0x04	; 4
  78:	de bf       	out	0x3e, r29	; 62
  7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
  7c:	11 e0       	ldi	r17, 0x01	; 1
  7e:	a0 e0       	ldi	r26, 0x00	; 0
  80:	b1 e0       	ldi	r27, 0x01	; 1
  82:	e4 e6       	ldi	r30, 0x64	; 100
  84:	f9 e0       	ldi	r31, 0x09	; 9
  86:	02 c0       	rjmp	.+4      	; 0x8c <__do_copy_data+0x10>
  88:	05 90       	lpm	r0, Z+
  8a:	0d 92       	st	X+, r0
  8c:	a2 35       	cpi	r26, 0x52	; 82
  8e:	b1 07       	cpc	r27, r17
  90:	d9 f7       	brne	.-10     	; 0x88 <__do_copy_data+0xc>

00000092 <__do_clear_bss>:
  92:	21 e0       	ldi	r18, 0x01	; 1
  94:	a2 e5       	ldi	r26, 0x52	; 82
  96:	b1 e0       	ldi	r27, 0x01	; 1
  98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
  9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
  9c:	a2 36       	cpi	r26, 0x62	; 98
  9e:	b2 07       	cpc	r27, r18
  a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
  a2:	0e 94 d7 02 	call	0x5ae	; 0x5ae <main>
  a6:	0c 94 b0 04 	jmp	0x960	; 0x960 <_exit>

000000aa <__bad_interrupt>:
  aa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ae <ADC_init>:

extern volatile uint8_t ADC_ready;

int ADC_init(void) {
	// Interrupt on rising edge PE0
	EMCUCR |= (1<<ISC2);
  ae:	86 b7       	in	r24, 0x36	; 54
  b0:	81 60       	ori	r24, 0x01	; 1
  b2:	86 bf       	out	0x36, r24	; 54

	// Enable interrupt on PE0
	GICR |= (1<<INT2);
  b4:	8b b7       	in	r24, 0x3b	; 59
  b6:	80 62       	ori	r24, 0x20	; 32
  b8:	8b bf       	out	0x3b, r24	; 59
	
	// Button input
	clr_bit(DDRE, PE0);
  ba:	30 98       	cbi	0x06, 0	; 6
	
	//Enable the external memory interface/4 bits address
	MCUCR |= (1<<SRE);
  bc:	85 b7       	in	r24, 0x35	; 53
  be:	80 68       	ori	r24, 0x80	; 128
  c0:	85 bf       	out	0x35, r24	; 53
	SFIOR |= (1<<XMM2);
  c2:	80 b7       	in	r24, 0x30	; 48
  c4:	80 62       	ori	r24, 0x20	; 32
  c6:	80 bf       	out	0x30, r24	; 48
	
	//Set the interrupt pin to input
	DDRE &= ~(1<<PINE0);
  c8:	30 98       	cbi	0x06, 0	; 6

	//set button pins to input
	clr_bit(DDRB, DDB0);
  ca:	b8 98       	cbi	0x17, 0	; 23
	clr_bit(DDRB, DDB1);
  cc:	b9 98       	cbi	0x17, 1	; 23
	
	//set joystick button to input
	clr_bit(DDRB, DDB2);
  ce:	ba 98       	cbi	0x17, 2	; 23
	return 0;
}
  d0:	80 e0       	ldi	r24, 0x00	; 0
  d2:	90 e0       	ldi	r25, 0x00	; 0
  d4:	08 95       	ret

000000d6 <ADC_read>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  d6:	e3 ef       	ldi	r30, 0xF3	; 243
  d8:	f1 e0       	ldi	r31, 0x01	; 1
  da:	31 97       	sbiw	r30, 0x01	; 1
  dc:	f1 f7       	brne	.-4      	; 0xda <ADC_read+0x4>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <ADC_read+0xa>
  e0:	00 00       	nop
uint8_t ADC_read(uint8_t channel) {
	//Address for the ADC
	volatile char *adc = (char *) 0x1400;
	_delay_ms(2);
	//Choose channel in ADC
	*adc = 0x04 | channel;
  e2:	84 60       	ori	r24, 0x04	; 4
  e4:	80 93 00 14 	sts	0x1400, r24
	while(!ADC_ready);
  e8:	80 91 55 01 	lds	r24, 0x0155
  ec:	88 23       	and	r24, r24
  ee:	e1 f3       	breq	.-8      	; 0xe8 <ADC_read+0x12>
	//ADC_ready = 0; 
	return *adc;
  f0:	80 91 00 14 	lds	r24, 0x1400
}
  f4:	08 95       	ret

000000f6 <__vector_3>:


ISR(INT2_vect){
  f6:	1f 92       	push	r1
  f8:	0f 92       	push	r0
  fa:	0f b6       	in	r0, 0x3f	; 63
  fc:	0f 92       	push	r0
  fe:	11 24       	eor	r1, r1
 100:	8f 93       	push	r24
	ADC_ready = 1;
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	80 93 55 01 	sts	0x0155, r24
	//wake up the CPU
}
 108:	8f 91       	pop	r24
 10a:	0f 90       	pop	r0
 10c:	0f be       	out	0x3f, r0	; 63
 10e:	0f 90       	pop	r0
 110:	1f 90       	pop	r1
 112:	18 95       	reti

00000114 <CAN_init>:
uint8_t last_joystick_pos_x = 0;
uint8_t last_slider_pos_r = 0;

Message msg;

int CAN_init(){
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	1f 92       	push	r1
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t value;
	
	//config-mode
	MCP2515_init();
 11e:	0e 94 b6 01 	call	0x36c	; 0x36c <MCP2515_init>
 122:	89 ef       	ldi	r24, 0xF9	; 249
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	01 97       	sbiw	r24, 0x01	; 1
 128:	f1 f7       	brne	.-4      	; 0x126 <CAN_init+0x12>
 12a:	00 c0       	rjmp	.+0      	; 0x12c <CAN_init+0x18>
 12c:	00 00       	nop
	//enable interrupts in MCP
	//Interrupt when message received in RXB0
		
	
	
	value = MCP2515_read(MCP_CANSTAT);
 12e:	8e e0       	ldi	r24, 0x0E	; 14
 130:	0e 94 bb 01 	call	0x376	; 0x376 <MCP2515_read>
 134:	89 83       	std	Y+1, r24	; 0x01
	if ((value & MODE_MASK) != MODE_CONFIG) {
 136:	89 81       	ldd	r24, Y+1	; 0x01
 138:	80 7e       	andi	r24, 0xE0	; 224
 13a:	80 38       	cpi	r24, 0x80	; 128
 13c:	39 f0       	breq	.+14     	; 0x14c <CAN_init+0x38>
		printf("MCP2515 is NOT in config mode after reset!\n");
 13e:	88 e0       	ldi	r24, 0x08	; 8
 140:	91 e0       	ldi	r25, 0x01	; 1
 142:	0e 94 60 04 	call	0x8c0	; 0x8c0 <puts>
		return 1;
 146:	81 e0       	ldi	r24, 0x01	; 1
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	1f c0       	rjmp	.+62     	; 0x18a <CAN_init+0x76>
	}
	
	MCP2515_bit_modify(MCP_CANINTE, 0x01, 0x01);
 14c:	41 e0       	ldi	r20, 0x01	; 1
 14e:	61 e0       	ldi	r22, 0x01	; 1
 150:	8b e2       	ldi	r24, 0x2B	; 43
 152:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MCP2515_bit_modify>
	MCP2515_bit_modify(MCP_RXB0CTRL, 0x60, 0xFF);
 156:	4f ef       	ldi	r20, 0xFF	; 255
 158:	60 e6       	ldi	r22, 0x60	; 96
 15a:	80 e6       	ldi	r24, 0x60	; 96
 15c:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MCP2515_bit_modify>
	
	//Set loopback-mode
	MCP2515_bit_modify(MCP_CANCTRL, MODE_MASK , MODE_NORMAL);
 160:	40 e0       	ldi	r20, 0x00	; 0
 162:	60 ee       	ldi	r22, 0xE0	; 224
 164:	8f e0       	ldi	r24, 0x0F	; 15
 166:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MCP2515_bit_modify>
	
	value = MCP2515_read(MCP_CANSTAT);
 16a:	8e e0       	ldi	r24, 0x0E	; 14
 16c:	0e 94 bb 01 	call	0x376	; 0x376 <MCP2515_read>
 170:	89 83       	std	Y+1, r24	; 0x01
	if ((value & MODE_MASK) != MODE_NORMAL) {
 172:	89 81       	ldd	r24, Y+1	; 0x01
 174:	80 7e       	andi	r24, 0xE0	; 224
 176:	39 f0       	breq	.+14     	; 0x186 <CAN_init+0x72>
		printf("MCP2515 is NOT in normal mode!\n");
 178:	83 e3       	ldi	r24, 0x33	; 51
 17a:	91 e0       	ldi	r25, 0x01	; 1
 17c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <puts>
		return 1;
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	02 c0       	rjmp	.+4      	; 0x18a <CAN_init+0x76>
	}
	
	return 0;
 186:	80 e0       	ldi	r24, 0x00	; 0
 188:	90 e0       	ldi	r25, 0x00	; 0
}
 18a:	0f 90       	pop	r0
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	08 95       	ret

00000192 <CAN_transmit_complete>:
		
	}
}

int CAN_transmit_complete(){
	if ( test_bit(MCP2515_read(MCP_TXB0CTRL), 3)){
 192:	80 e3       	ldi	r24, 0x30	; 48
 194:	0e 94 bb 01 	call	0x376	; 0x376 <MCP2515_read>
 198:	86 95       	lsr	r24
 19a:	86 95       	lsr	r24
 19c:	86 95       	lsr	r24
 19e:	91 e0       	ldi	r25, 0x01	; 1
 1a0:	89 27       	eor	r24, r25
		return 0;
	}
	return 1;
}
 1a2:	81 70       	andi	r24, 0x01	; 1
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	08 95       	ret

000001a8 <CAN_send>:
	
	return 0;
}


void CAN_send(Message* msg){
 1a8:	ef 92       	push	r14
 1aa:	ff 92       	push	r15
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
 1b0:	cf 93       	push	r28
 1b2:	df 93       	push	r29
 1b4:	7c 01       	movw	r14, r24
	if(CAN_transmit_complete()){
 1b6:	0e 94 c9 00 	call	0x192	; 0x192 <CAN_transmit_complete>
 1ba:	89 2b       	or	r24, r25
 1bc:	d9 f1       	breq	.+118    	; 0x234 <CAN_send+0x8c>
		
		//sending ID
		MCP2515_write(MCP_TXB0SIDH, (uint8_t)msg->ID >> 3);
 1be:	f7 01       	movw	r30, r14
 1c0:	60 81       	ld	r22, Z
 1c2:	66 95       	lsr	r22
 1c4:	66 95       	lsr	r22
 1c6:	66 95       	lsr	r22
 1c8:	81 e3       	ldi	r24, 0x31	; 49
 1ca:	0e 94 ce 01 	call	0x39c	; 0x39c <MCP2515_write>
		MCP2515_write(MCP_TXB0SIDL, (uint8_t)msg->ID << 5);
 1ce:	f7 01       	movw	r30, r14
 1d0:	60 81       	ld	r22, Z
 1d2:	62 95       	swap	r22
 1d4:	66 0f       	add	r22, r22
 1d6:	60 7e       	andi	r22, 0xE0	; 224
 1d8:	82 e3       	ldi	r24, 0x32	; 50
 1da:	0e 94 ce 01 	call	0x39c	; 0x39c <MCP2515_write>
	
		//sending data length
		MCP2515_write(MCP_TXB0DLC, msg->length & 0x0F);
 1de:	f7 01       	movw	r30, r14
 1e0:	62 81       	ldd	r22, Z+2	; 0x02
 1e2:	6f 70       	andi	r22, 0x0F	; 15
 1e4:	85 e3       	ldi	r24, 0x35	; 53
 1e6:	0e 94 ce 01 	call	0x39c	; 0x39c <MCP2515_write>
	
		//Sending data, max 8 bytes
		if(msg->length > 8){
 1ea:	f7 01       	movw	r30, r14
 1ec:	82 81       	ldd	r24, Z+2	; 0x02
 1ee:	93 81       	ldd	r25, Z+3	; 0x03
 1f0:	89 30       	cpi	r24, 0x09	; 9
 1f2:	91 05       	cpc	r25, r1
 1f4:	54 f0       	brlt	.+20     	; 0x20a <CAN_send+0x62>
			msg->length = 8;
 1f6:	88 e0       	ldi	r24, 0x08	; 8
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	93 83       	std	Z+3, r25	; 0x03
 1fc:	82 83       	std	Z+2, r24	; 0x02
 1fe:	87 01       	movw	r16, r14
 200:	0c 5f       	subi	r16, 0xFC	; 252
 202:	1f 4f       	sbci	r17, 0xFF	; 255
	
	return 0;
}


void CAN_send(Message* msg){
 204:	c0 e0       	ldi	r28, 0x00	; 0
 206:	d0 e0       	ldi	r29, 0x00	; 0
 208:	04 c0       	rjmp	.+8      	; 0x212 <CAN_send+0x6a>
	
		//Sending data, max 8 bytes
		if(msg->length > 8){
			msg->length = 8;
		}
		for (int i = 0; i < msg->length; i++){
 20a:	18 16       	cp	r1, r24
 20c:	19 06       	cpc	r1, r25
 20e:	bc f3       	brlt	.-18     	; 0x1fe <CAN_send+0x56>
 210:	0e c0       	rjmp	.+28     	; 0x22e <CAN_send+0x86>
			MCP2515_write(MCP_TXB0D0 + i, msg->data[i]);  
 212:	f8 01       	movw	r30, r16
 214:	61 91       	ld	r22, Z+
 216:	8f 01       	movw	r16, r30
 218:	8c 2f       	mov	r24, r28
 21a:	8a 5c       	subi	r24, 0xCA	; 202
 21c:	0e 94 ce 01 	call	0x39c	; 0x39c <MCP2515_write>
	
		//Sending data, max 8 bytes
		if(msg->length > 8){
			msg->length = 8;
		}
		for (int i = 0; i < msg->length; i++){
 220:	21 96       	adiw	r28, 0x01	; 1
 222:	f7 01       	movw	r30, r14
 224:	22 81       	ldd	r18, Z+2	; 0x02
 226:	33 81       	ldd	r19, Z+3	; 0x03
 228:	c2 17       	cp	r28, r18
 22a:	d3 07       	cpc	r29, r19
 22c:	94 f3       	brlt	.-28     	; 0x212 <CAN_send+0x6a>
			MCP2515_write(MCP_TXB0D0 + i, msg->data[i]);  
		}
	
		//initiate message transmission
		
		MCP2515_request_to_send(1);
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <MCP2515_request_to_send>
		
	}
}
 234:	df 91       	pop	r29
 236:	cf 91       	pop	r28
 238:	1f 91       	pop	r17
 23a:	0f 91       	pop	r16
 23c:	ff 90       	pop	r15
 23e:	ef 90       	pop	r14
 240:	08 95       	ret

00000242 <CAN_int_vect>:
	return 0; 
}

void CAN_int_vect(){
	//set recieve flag to 0
	MCP2515_bit_modify(MCP_CANINTF, 0x01, 0x00);
 242:	40 e0       	ldi	r20, 0x00	; 0
 244:	61 e0       	ldi	r22, 0x01	; 1
 246:	8c e2       	ldi	r24, 0x2C	; 44
 248:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MCP2515_bit_modify>
	//set transmit flag to 0 
	MCP2515_bit_modify(MCP_CANINTF, 0x04, 0x00);
 24c:	40 e0       	ldi	r20, 0x00	; 0
 24e:	64 e0       	ldi	r22, 0x04	; 4
 250:	8c e2       	ldi	r24, 0x2C	; 44
 252:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MCP2515_bit_modify>
	rx_int_flag = 1;
 256:	81 e0       	ldi	r24, 0x01	; 1
 258:	80 93 54 01 	sts	0x0154, r24
 25c:	08 95       	ret

0000025e <CAN_send_msg>:
	
}


void CAN_send_msg(void){
 25e:	ef 92       	push	r14
 260:	ff 92       	push	r15
 262:	0f 93       	push	r16
 264:	1f 93       	push	r17
 266:	cf 93       	push	r28
 268:	df 93       	push	r29
 26a:	cd b7       	in	r28, 0x3d	; 61
 26c:	de b7       	in	r29, 0x3e	; 62
 26e:	2c 97       	sbiw	r28, 0x0c	; 12
 270:	0f b6       	in	r0, 0x3f	; 63
 272:	f8 94       	cli
 274:	de bf       	out	0x3e, r29	; 62
 276:	0f be       	out	0x3f, r0	; 63
 278:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t joy_pos_x = joystick_read(CHANNEL_X);
 27a:	84 e0       	ldi	r24, 0x04	; 4
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	0e 94 28 02 	call	0x450	; 0x450 <joystick_read>
 282:	8c 01       	movw	r16, r24
	uint8_t joy_pos_y = joystick_read(CHANNEL_Y);
 284:	85 e0       	ldi	r24, 0x05	; 5
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	0e 94 28 02 	call	0x450	; 0x450 <joystick_read>
	uint8_t slider_pos_r = slider_read(SLIDER_R);
 28c:	86 e0       	ldi	r24, 0x06	; 6
 28e:	90 e0       	ldi	r25, 0x00	; 0
 290:	0e 94 2c 02 	call	0x458	; 0x458 <slider_read>
 294:	7c 01       	movw	r14, r24
	uint8_t slider_pos_l = slider_read(SLIDER_L);
 296:	87 e0       	ldi	r24, 0x07	; 7
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	0e 94 2c 02 	call	0x458	; 0x458 <slider_read>
	printf("x_pos %d \t ", joy_pos_x);
	printf("y_pos %d \t ", joy_pos_y);
	printf("slider_l_pos %d \t ", slider_pos_l);
	printf("slider %d \n", slider_pos_r);
	*/
	if(abs(joy_pos_x - last_joystick_pos_x) > 10 || abs(slider_pos_r - last_slider_pos_r) > 10){
 29e:	c8 01       	movw	r24, r16
 2a0:	99 27       	eor	r25, r25
 2a2:	20 91 53 01 	lds	r18, 0x0153
 2a6:	82 1b       	sub	r24, r18
 2a8:	91 09       	sbc	r25, r1
 2aa:	9c 01       	movw	r18, r24
 2ac:	22 f4       	brpl	.+8      	; 0x2b6 <CAN_send_msg+0x58>
 2ae:	22 27       	eor	r18, r18
 2b0:	33 27       	eor	r19, r19
 2b2:	28 1b       	sub	r18, r24
 2b4:	39 0b       	sbc	r19, r25
 2b6:	2b 30       	cpi	r18, 0x0B	; 11
 2b8:	31 05       	cpc	r19, r1
 2ba:	7c f4       	brge	.+30     	; 0x2da <CAN_send_msg+0x7c>
 2bc:	80 91 52 01 	lds	r24, 0x0152
 2c0:	97 01       	movw	r18, r14
 2c2:	33 27       	eor	r19, r19
 2c4:	28 1b       	sub	r18, r24
 2c6:	31 09       	sbc	r19, r1
 2c8:	c9 01       	movw	r24, r18
 2ca:	99 23       	and	r25, r25
 2cc:	24 f4       	brge	.+8      	; 0x2d6 <CAN_send_msg+0x78>
 2ce:	88 27       	eor	r24, r24
 2d0:	99 27       	eor	r25, r25
 2d2:	82 1b       	sub	r24, r18
 2d4:	93 0b       	sbc	r25, r19
 2d6:	0b 97       	sbiw	r24, 0x0b	; 11
 2d8:	84 f0       	brlt	.+32     	; 0x2fa <CAN_send_msg+0x9c>
		Message msg;
		
		msg.length = 3;
 2da:	83 e0       	ldi	r24, 0x03	; 3
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	9c 83       	std	Y+4, r25	; 0x04
 2e0:	8b 83       	std	Y+3, r24	; 0x03
		msg.data[0] = joy_pos_x;
 2e2:	0d 83       	std	Y+5, r16	; 0x05
		msg.data[1] = slider_pos_r;
 2e4:	ee 82       	std	Y+6, r14	; 0x06
		msg.ID = 0;
 2e6:	1a 82       	std	Y+2, r1	; 0x02
 2e8:	19 82       	std	Y+1, r1	; 0x01
		
		CAN_send(&msg);
 2ea:	ce 01       	movw	r24, r28
 2ec:	01 96       	adiw	r24, 0x01	; 1
 2ee:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <CAN_send>
		last_joystick_pos_x = joy_pos_x;
 2f2:	00 93 53 01 	sts	0x0153, r16
		last_slider_pos_r = slider_pos_r;
 2f6:	e0 92 52 01 	sts	0x0152, r14
	}
}
 2fa:	2c 96       	adiw	r28, 0x0c	; 12
 2fc:	0f b6       	in	r0, 0x3f	; 63
 2fe:	f8 94       	cli
 300:	de bf       	out	0x3e, r29	; 62
 302:	0f be       	out	0x3f, r0	; 63
 304:	cd bf       	out	0x3d, r28	; 61
 306:	df 91       	pop	r29
 308:	cf 91       	pop	r28
 30a:	1f 91       	pop	r17
 30c:	0f 91       	pop	r16
 30e:	ff 90       	pop	r15
 310:	ef 90       	pop	r14
 312:	08 95       	ret

00000314 <__vector_1>:

ISR(INT0_vect){
 314:	1f 92       	push	r1
 316:	0f 92       	push	r0
 318:	0f b6       	in	r0, 0x3f	; 63
 31a:	0f 92       	push	r0
 31c:	11 24       	eor	r1, r1
 31e:	2f 93       	push	r18
 320:	3f 93       	push	r19
 322:	4f 93       	push	r20
 324:	5f 93       	push	r21
 326:	6f 93       	push	r22
 328:	7f 93       	push	r23
 32a:	8f 93       	push	r24
 32c:	9f 93       	push	r25
 32e:	af 93       	push	r26
 330:	bf 93       	push	r27
 332:	ef 93       	push	r30
 334:	ff 93       	push	r31
	//RX0 interrupt flag set to 0
	CAN_int_vect();
 336:	0e 94 21 01 	call	0x242	; 0x242 <CAN_int_vect>
}
 33a:	ff 91       	pop	r31
 33c:	ef 91       	pop	r30
 33e:	bf 91       	pop	r27
 340:	af 91       	pop	r26
 342:	9f 91       	pop	r25
 344:	8f 91       	pop	r24
 346:	7f 91       	pop	r23
 348:	6f 91       	pop	r22
 34a:	5f 91       	pop	r21
 34c:	4f 91       	pop	r20
 34e:	3f 91       	pop	r19
 350:	2f 91       	pop	r18
 352:	0f 90       	pop	r0
 354:	0f be       	out	0x3f, r0	; 63
 356:	0f 90       	pop	r0
 358:	1f 90       	pop	r1
 35a:	18 95       	reti

0000035c <MCP2515_reset>:
	//set MCP2515 in configuration mode
	MCP2515_reset(); 
}

void MCP2515_reset(void){
	SPI_activate_SS();
 35c:	0e 94 b9 02 	call	0x572	; 0x572 <SPI_activate_SS>
	SPI_read_write(MCP_RESET);
 360:	80 ec       	ldi	r24, 0xC0	; 192
 362:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_deactivate_SS();
 366:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
 36a:	08 95       	ret

0000036c <MCP2515_init>:
#include "MCP2515.h"
#include "MCP2515_driver.h"
#include <string.h>

void MCP2515_init(void){
	SPI_init();
 36c:	0e 94 bd 02 	call	0x57a	; 0x57a <SPI_init>
	//set MCP2515 in configuration mode
	MCP2515_reset(); 
 370:	0e 94 ae 01 	call	0x35c	; 0x35c <MCP2515_reset>
 374:	08 95       	ret

00000376 <MCP2515_read>:
	SPI_activate_SS();
	SPI_read_write(MCP_RESET);
	SPI_deactivate_SS();
}

uint8_t MCP2515_read(uint8_t address){
 376:	cf 93       	push	r28
 378:	c8 2f       	mov	r28, r24
	uint8_t data;
	SPI_activate_SS();
 37a:	0e 94 b9 02 	call	0x572	; 0x572 <SPI_activate_SS>
	SPI_read_write(MCP_READ);
 37e:	83 e0       	ldi	r24, 0x03	; 3
 380:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(address);
 384:	8c 2f       	mov	r24, r28
 386:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	data = SPI_read_write(0x00);
 38a:	80 e0       	ldi	r24, 0x00	; 0
 38c:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
 390:	c8 2f       	mov	r28, r24
	SPI_deactivate_SS();
 392:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
	return data;
}
 396:	8c 2f       	mov	r24, r28
 398:	cf 91       	pop	r28
 39a:	08 95       	ret

0000039c <MCP2515_write>:

void MCP2515_write(uint8_t address, char data){
 39c:	cf 93       	push	r28
 39e:	df 93       	push	r29
 3a0:	d8 2f       	mov	r29, r24
 3a2:	c6 2f       	mov	r28, r22
	SPI_activate_SS();
 3a4:	0e 94 b9 02 	call	0x572	; 0x572 <SPI_activate_SS>
	SPI_read_write(MCP_WRITE);
 3a8:	82 e0       	ldi	r24, 0x02	; 2
 3aa:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(address);
 3ae:	8d 2f       	mov	r24, r29
 3b0:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(data);
 3b4:	8c 2f       	mov	r24, r28
 3b6:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_deactivate_SS();
 3ba:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
}
 3be:	df 91       	pop	r29
 3c0:	cf 91       	pop	r28
 3c2:	08 95       	ret

000003c4 <MCP2515_request_to_send>:

 void MCP2515_request_to_send(uint8_t command){
 3c4:	cf 93       	push	r28
 3c6:	c8 2f       	mov	r28, r24
	SPI_activate_SS();
 3c8:	0e 94 b9 02 	call	0x572	; 0x572 <SPI_activate_SS>
	if (command <= 7){
 3cc:	c8 30       	cpi	r28, 0x08	; 8
 3ce:	28 f4       	brcc	.+10     	; 0x3da <MCP2515_request_to_send+0x16>
		SPI_read_write(MCP_RTS | command);
 3d0:	8c 2f       	mov	r24, r28
 3d2:	80 68       	ori	r24, 0x80	; 128
 3d4:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
 3d8:	03 c0       	rjmp	.+6      	; 0x3e0 <MCP2515_request_to_send+0x1c>
	}
	else{
		SPI_read_write(MCP_RTS);
 3da:	80 e8       	ldi	r24, 0x80	; 128
 3dc:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	}
	SPI_deactivate_SS();
 3e0:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
}
 3e4:	cf 91       	pop	r28
 3e6:	08 95       	ret

000003e8 <MCP2515_bit_modify>:
	SPI_deactivate_SS();	
	return status;
}


void MCP2515_bit_modify(uint8_t address, uint8_t mask_byte, uint8_t data_byte){
 3e8:	1f 93       	push	r17
 3ea:	cf 93       	push	r28
 3ec:	df 93       	push	r29
 3ee:	18 2f       	mov	r17, r24
 3f0:	d6 2f       	mov	r29, r22
 3f2:	c4 2f       	mov	r28, r20
	SPI_activate_SS();
 3f4:	0e 94 b9 02 	call	0x572	; 0x572 <SPI_activate_SS>
	SPI_read_write(MCP_BITMOD);
 3f8:	85 e0       	ldi	r24, 0x05	; 5
 3fa:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(address);
 3fe:	81 2f       	mov	r24, r17
 400:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(mask_byte);
 404:	8d 2f       	mov	r24, r29
 406:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_read_write(data_byte);
 40a:	8c 2f       	mov	r24, r28
 40c:	0e 94 b4 02 	call	0x568	; 0x568 <SPI_read_write>
	SPI_deactivate_SS();
 410:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	1f 91       	pop	r17
 41a:	08 95       	ret

0000041c <UART_transmit>:

int UART_transmit(unsigned char data, FILE *stream){
	
	//Wait for empty transmit buffer
	
	while( !( UCSR0A & (1<<UDRE0)) );
 41c:	5d 9b       	sbis	0x0b, 5	; 11
 41e:	fe cf       	rjmp	.-4      	; 0x41c <UART_transmit>
 
	//Put data into buffer, sends the data
 
	UDR0 = data;
 420:	8c b9       	out	0x0c, r24	; 12
	return 0; 
}
 422:	80 e0       	ldi	r24, 0x00	; 0
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	08 95       	ret

00000428 <UART_receive>:

unsigned char UART_receive(){

	//Wait for data to be received

	while( !(UCSR0A & (1<<RXC0)) );
 428:	5f 9b       	sbis	0x0b, 7	; 11
 42a:	fe cf       	rjmp	.-4      	; 0x428 <UART_receive>
 
	//Get and return received data from buffer
 
	return UDR0;
 42c:	8c b1       	in	r24, 0x0c	; 12
}
 42e:	08 95       	ret

00000430 <UART_init>:

int UART_init(unsigned int ubrr ){
/* 
Set baud rate
 */
	UBRR0L = ubrr;
 430:	89 b9       	out	0x09, r24	; 9

/* 
Enable receiver and transmitter
 */
	UCSR0B =(1<<RXEN0)|(1<<TXEN0);
 432:	88 e1       	ldi	r24, 0x18	; 24
 434:	8a b9       	out	0x0a, r24	; 10
	
	uart = fdevopen(&UART_transmit, &UART_receive);
 436:	64 e1       	ldi	r22, 0x14	; 20
 438:	72 e0       	ldi	r23, 0x02	; 2
 43a:	8e e0       	ldi	r24, 0x0E	; 14
 43c:	92 e0       	ldi	r25, 0x02	; 2
 43e:	0e 94 15 04 	call	0x82a	; 0x82a <fdevopen>
 442:	90 93 57 01 	sts	0x0157, r25
 446:	80 93 56 01 	sts	0x0156, r24
	
	return 0; 
}
 44a:	80 e0       	ldi	r24, 0x00	; 0
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	08 95       	ret

00000450 <joystick_read>:



int joystick_read(int channel){
	//Return 0-255
	return ADC_read(channel);
 450:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_read>
}
 454:	90 e0       	ldi	r25, 0x00	; 0
 456:	08 95       	ret

00000458 <slider_read>:


int slider_read(int channel){
	//Return 0-255
	return ADC_read(channel);
 458:	0e 94 6b 00 	call	0xd6	; 0xd6 <ADC_read>
}
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	08 95       	ret

00000460 <oled_init>:



void oled_init(){
	//  display  off
	*OLED_c = 0xae;
 460:	e0 91 06 01 	lds	r30, 0x0106
 464:	f0 91 07 01 	lds	r31, 0x0107
 468:	8e ea       	ldi	r24, 0xAE	; 174
 46a:	80 83       	st	Z, r24

	//segment  remap
	*OLED_c = 0xa1;	
 46c:	e0 91 06 01 	lds	r30, 0x0106
 470:	f0 91 07 01 	lds	r31, 0x0107
 474:	81 ea       	ldi	r24, 0xA1	; 161
 476:	80 83       	st	Z, r24

	//common  pads  hardware:  alternative		
	*OLED_c = 0xda;			
 478:	e0 91 06 01 	lds	r30, 0x0106
 47c:	f0 91 07 01 	lds	r31, 0x0107
 480:	8a ed       	ldi	r24, 0xDA	; 218
 482:	80 83       	st	Z, r24
	*OLED_c = 0x12;
 484:	e0 91 06 01 	lds	r30, 0x0106
 488:	f0 91 07 01 	lds	r31, 0x0107
 48c:	82 e1       	ldi	r24, 0x12	; 18
 48e:	80 83       	st	Z, r24

	//common output scan direction:com63~com0
	*OLED_c = 0xc8;
 490:	e0 91 06 01 	lds	r30, 0x0106
 494:	f0 91 07 01 	lds	r31, 0x0107
 498:	88 ec       	ldi	r24, 0xC8	; 200
 49a:	80 83       	st	Z, r24

	//multiplex  ration  mode:63
	*OLED_c = 0xa8;
 49c:	e0 91 06 01 	lds	r30, 0x0106
 4a0:	f0 91 07 01 	lds	r31, 0x0107
 4a4:	88 ea       	ldi	r24, 0xA8	; 168
 4a6:	80 83       	st	Z, r24
	*OLED_c = 0x3f;
 4a8:	e0 91 06 01 	lds	r30, 0x0106
 4ac:	f0 91 07 01 	lds	r31, 0x0107
 4b0:	8f e3       	ldi	r24, 0x3F	; 63
 4b2:	80 83       	st	Z, r24

	//display divide ratio/osc. freq. mode
	*OLED_c = 0xd5;
 4b4:	e0 91 06 01 	lds	r30, 0x0106
 4b8:	f0 91 07 01 	lds	r31, 0x0107
 4bc:	85 ed       	ldi	r24, 0xD5	; 213
 4be:	80 83       	st	Z, r24
	*OLED_c = 0x80;
 4c0:	e0 91 06 01 	lds	r30, 0x0106
 4c4:	f0 91 07 01 	lds	r31, 0x0107
 4c8:	80 e8       	ldi	r24, 0x80	; 128
 4ca:	80 83       	st	Z, r24

	//contrast  control
	*OLED_c = 0x81;
 4cc:	e0 91 06 01 	lds	r30, 0x0106
 4d0:	f0 91 07 01 	lds	r31, 0x0107
 4d4:	81 e8       	ldi	r24, 0x81	; 129
 4d6:	80 83       	st	Z, r24
	*OLED_c = 0x50;
 4d8:	e0 91 06 01 	lds	r30, 0x0106
 4dc:	f0 91 07 01 	lds	r31, 0x0107
 4e0:	80 e5       	ldi	r24, 0x50	; 80
 4e2:	80 83       	st	Z, r24

	//set  pre-charge  period
	*OLED_c = 0xd9;
 4e4:	e0 91 06 01 	lds	r30, 0x0106
 4e8:	f0 91 07 01 	lds	r31, 0x0107
 4ec:	89 ed       	ldi	r24, 0xD9	; 217
 4ee:	80 83       	st	Z, r24
	*OLED_c = 0x21;
 4f0:	e0 91 06 01 	lds	r30, 0x0106
 4f4:	f0 91 07 01 	lds	r31, 0x0107
 4f8:	81 e2       	ldi	r24, 0x21	; 33
 4fa:	80 83       	st	Z, r24

	 //Set  Memory  Addressing  Mode
	*OLED_c = 0x20;
 4fc:	e0 91 06 01 	lds	r30, 0x0106
 500:	f0 91 07 01 	lds	r31, 0x0107
 504:	80 e2       	ldi	r24, 0x20	; 32
 506:	80 83       	st	Z, r24
	*OLED_c = 0x02;
 508:	e0 91 06 01 	lds	r30, 0x0106
 50c:	f0 91 07 01 	lds	r31, 0x0107
 510:	82 e0       	ldi	r24, 0x02	; 2
 512:	80 83       	st	Z, r24

	//VCOM  deselect  level  mode
	*OLED_c = 0xdb;
 514:	e0 91 06 01 	lds	r30, 0x0106
 518:	f0 91 07 01 	lds	r31, 0x0107
 51c:	8b ed       	ldi	r24, 0xDB	; 219
 51e:	80 83       	st	Z, r24
	*OLED_c = 0x30;
 520:	e0 91 06 01 	lds	r30, 0x0106
 524:	f0 91 07 01 	lds	r31, 0x0107
 528:	80 e3       	ldi	r24, 0x30	; 48
 52a:	80 83       	st	Z, r24

	//master  configuration
	*OLED_c = 0xad;
 52c:	e0 91 06 01 	lds	r30, 0x0106
 530:	f0 91 07 01 	lds	r31, 0x0107
 534:	8d ea       	ldi	r24, 0xAD	; 173
 536:	80 83       	st	Z, r24

	//out follows RAM content 
	*OLED_c = 0x00;
 538:	e0 91 06 01 	lds	r30, 0x0106
 53c:	f0 91 07 01 	lds	r31, 0x0107
 540:	10 82       	st	Z, r1
	
	//set  normal  display
	*OLED_c = 0xa4;
 542:	e0 91 06 01 	lds	r30, 0x0106
 546:	f0 91 07 01 	lds	r31, 0x0107
 54a:	84 ea       	ldi	r24, 0xA4	; 164
 54c:	80 83       	st	Z, r24
	*OLED_c = 0xa6;
 54e:	e0 91 06 01 	lds	r30, 0x0106
 552:	f0 91 07 01 	lds	r31, 0x0107
 556:	86 ea       	ldi	r24, 0xA6	; 166
 558:	80 83       	st	Z, r24
	
	//  display  on
	*OLED_c = 0xaf;
 55a:	e0 91 06 01 	lds	r30, 0x0106
 55e:	f0 91 07 01 	lds	r31, 0x0107
 562:	8f ea       	ldi	r24, 0xAF	; 175
 564:	80 83       	st	Z, r24
 566:	08 95       	ret

00000568 <SPI_read_write>:
}

uint8_t SPI_read_write(char cData){
	/* Start transmission */
	
	SPDR = cData;
 568:	8f b9       	out	0x0f, r24	; 15
	/* Wait for transmission complete */
	while(!(test_bit(SPSR, SPIF)));   //wait until SPIF-flag is set. 
 56a:	77 9b       	sbis	0x0e, 7	; 14
 56c:	fe cf       	rjmp	.-4      	; 0x56a <SPI_read_write+0x2>
	return SPDR;
 56e:	8f b1       	in	r24, 0x0f	; 15
}
 570:	08 95       	ret

00000572 <SPI_activate_SS>:

void SPI_activate_SS(){
	clr_bit(PORTB, SS);
 572:	c4 98       	cbi	0x18, 4	; 24
 574:	08 95       	ret

00000576 <SPI_deactivate_SS>:
}

void SPI_deactivate_SS(){
	set_bit(PORTB, SS);
 576:	c4 9a       	sbi	0x18, 4	; 24
 578:	08 95       	ret

0000057a <SPI_init>:
#include <avr/io.h>


void SPI_init(void){
	//SPI enable
	set_bit(SPCR, SPE);
 57a:	6e 9a       	sbi	0x0d, 6	; 13
	//Data order MSB transmitted first
	//clr_bit(SPCR, DORD);
	//Set SPI to master mode
	set_bit(SPCR, MSTR);
 57c:	6c 9a       	sbi	0x0d, 4	; 13
	
	//set SPI clock rate = Fosc/2
	set_bit(SPSR, SPI2X);
 57e:	70 9a       	sbi	0x0e, 0	; 14
	
	
	//set MOSI and SCK to output, all others input
	set_bit(DDRB, MOSI);
 580:	bd 9a       	sbi	0x17, 5	; 23
	set_bit(DDRB, SCK);
 582:	bf 9a       	sbi	0x17, 7	; 23
	set_bit(DDRB, SS);
 584:	bc 9a       	sbi	0x17, 4	; 23
	
	SPI_deactivate_SS();
 586:	0e 94 bb 02 	call	0x576	; 0x576 <SPI_deactivate_SS>
 58a:	08 95       	ret

0000058c <register_init>:
#define REGISTER_INIT_H_
void register_init(void);

void register_init(void){
	//enabler externt minne i MCU
	set_bit(MCUCR, SRE);
 58c:	85 b7       	in	r24, 0x35	; 53
 58e:	80 68       	ori	r24, 0x80	; 128
 590:	85 bf       	out	0x35, r24	; 53
	set_bit(SFIOR, XMM2);
 592:	80 b7       	in	r24, 0x30	; 48
 594:	80 62       	ori	r24, 0x20	; 32
 596:	80 bf       	out	0x30, r24	; 48

	//enable interrupts in MCU
	clr_bit(MCUCR,ISC00);
 598:	85 b7       	in	r24, 0x35	; 53
 59a:	8e 7f       	andi	r24, 0xFE	; 254
 59c:	85 bf       	out	0x35, r24	; 53
	set_bit(MCUCR,ISC01);
 59e:	85 b7       	in	r24, 0x35	; 53
 5a0:	82 60       	ori	r24, 0x02	; 2
 5a2:	85 bf       	out	0x35, r24	; 53
	set_bit(GICR,INT0);
 5a4:	8b b7       	in	r24, 0x3b	; 59
 5a6:	80 64       	ori	r24, 0x40	; 64
 5a8:	8b bf       	out	0x3b, r24	; 59
	
	
	clr_bit(DDRD, DDD2);
 5aa:	8a 98       	cbi	0x11, 2	; 17
 5ac:	08 95       	ret

000005ae <main>:
//volatile uint8_t* a = 0x1400;


int main(void) {
	// Disable global interrupts
	cli();
 5ae:	f8 94       	cli
	UART_init(31);
 5b0:	8f e1       	ldi	r24, 0x1F	; 31
 5b2:	90 e0       	ldi	r25, 0x00	; 0
 5b4:	0e 94 18 02 	call	0x430	; 0x430 <UART_init>
	register_init();
 5b8:	0e 94 c6 02 	call	0x58c	; 0x58c <register_init>
	oled_init();
 5bc:	0e 94 30 02 	call	0x460	; 0x460 <oled_init>
	ADC_init();
 5c0:	0e 94 57 00 	call	0xae	; 0xae <ADC_init>
	CAN_init();
 5c4:	0e 94 8a 00 	call	0x114	; 0x114 <CAN_init>
	//Enable global interrupts
	sei();
 5c8:	78 94       	sei
	
	

	
	while(1){
		CAN_send_msg();
 5ca:	0e 94 2f 01 	call	0x25e	; 0x25e <CAN_send_msg>
		
		//printf("Y %d \t", ADC_read(CHANNEL_X));
		//printf("X %d\n", ADC_read(CHANNEL_Y));
	
		if(ADC_ready){
 5ce:	80 91 55 01 	lds	r24, 0x0155
 5d2:	88 23       	and	r24, r24
 5d4:	d1 f3       	breq	.-12     	; 0x5ca <main+0x1c>
			ADC_ready = 0;
 5d6:	10 92 55 01 	sts	0x0155, r1
 5da:	f7 cf       	rjmp	.-18     	; 0x5ca <main+0x1c>

000005dc <malloc>:
 5dc:	cf 93       	push	r28
 5de:	df 93       	push	r29
 5e0:	82 30       	cpi	r24, 0x02	; 2
 5e2:	91 05       	cpc	r25, r1
 5e4:	10 f4       	brcc	.+4      	; 0x5ea <malloc+0xe>
 5e6:	82 e0       	ldi	r24, 0x02	; 2
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	e0 91 5a 01 	lds	r30, 0x015A
 5ee:	f0 91 5b 01 	lds	r31, 0x015B
 5f2:	20 e0       	ldi	r18, 0x00	; 0
 5f4:	30 e0       	ldi	r19, 0x00	; 0
 5f6:	a0 e0       	ldi	r26, 0x00	; 0
 5f8:	b0 e0       	ldi	r27, 0x00	; 0
 5fa:	30 97       	sbiw	r30, 0x00	; 0
 5fc:	39 f1       	breq	.+78     	; 0x64c <malloc+0x70>
 5fe:	40 81       	ld	r20, Z
 600:	51 81       	ldd	r21, Z+1	; 0x01
 602:	48 17       	cp	r20, r24
 604:	59 07       	cpc	r21, r25
 606:	b8 f0       	brcs	.+46     	; 0x636 <malloc+0x5a>
 608:	48 17       	cp	r20, r24
 60a:	59 07       	cpc	r21, r25
 60c:	71 f4       	brne	.+28     	; 0x62a <malloc+0x4e>
 60e:	82 81       	ldd	r24, Z+2	; 0x02
 610:	93 81       	ldd	r25, Z+3	; 0x03
 612:	10 97       	sbiw	r26, 0x00	; 0
 614:	29 f0       	breq	.+10     	; 0x620 <malloc+0x44>
 616:	13 96       	adiw	r26, 0x03	; 3
 618:	9c 93       	st	X, r25
 61a:	8e 93       	st	-X, r24
 61c:	12 97       	sbiw	r26, 0x02	; 2
 61e:	2c c0       	rjmp	.+88     	; 0x678 <malloc+0x9c>
 620:	90 93 5b 01 	sts	0x015B, r25
 624:	80 93 5a 01 	sts	0x015A, r24
 628:	27 c0       	rjmp	.+78     	; 0x678 <malloc+0x9c>
 62a:	21 15       	cp	r18, r1
 62c:	31 05       	cpc	r19, r1
 62e:	31 f0       	breq	.+12     	; 0x63c <malloc+0x60>
 630:	42 17       	cp	r20, r18
 632:	53 07       	cpc	r21, r19
 634:	18 f0       	brcs	.+6      	; 0x63c <malloc+0x60>
 636:	a9 01       	movw	r20, r18
 638:	db 01       	movw	r26, r22
 63a:	01 c0       	rjmp	.+2      	; 0x63e <malloc+0x62>
 63c:	ef 01       	movw	r28, r30
 63e:	9a 01       	movw	r18, r20
 640:	bd 01       	movw	r22, r26
 642:	df 01       	movw	r26, r30
 644:	02 80       	ldd	r0, Z+2	; 0x02
 646:	f3 81       	ldd	r31, Z+3	; 0x03
 648:	e0 2d       	mov	r30, r0
 64a:	d7 cf       	rjmp	.-82     	; 0x5fa <malloc+0x1e>
 64c:	21 15       	cp	r18, r1
 64e:	31 05       	cpc	r19, r1
 650:	f9 f0       	breq	.+62     	; 0x690 <malloc+0xb4>
 652:	28 1b       	sub	r18, r24
 654:	39 0b       	sbc	r19, r25
 656:	24 30       	cpi	r18, 0x04	; 4
 658:	31 05       	cpc	r19, r1
 65a:	80 f4       	brcc	.+32     	; 0x67c <malloc+0xa0>
 65c:	8a 81       	ldd	r24, Y+2	; 0x02
 65e:	9b 81       	ldd	r25, Y+3	; 0x03
 660:	61 15       	cp	r22, r1
 662:	71 05       	cpc	r23, r1
 664:	21 f0       	breq	.+8      	; 0x66e <malloc+0x92>
 666:	fb 01       	movw	r30, r22
 668:	93 83       	std	Z+3, r25	; 0x03
 66a:	82 83       	std	Z+2, r24	; 0x02
 66c:	04 c0       	rjmp	.+8      	; 0x676 <malloc+0x9a>
 66e:	90 93 5b 01 	sts	0x015B, r25
 672:	80 93 5a 01 	sts	0x015A, r24
 676:	fe 01       	movw	r30, r28
 678:	32 96       	adiw	r30, 0x02	; 2
 67a:	44 c0       	rjmp	.+136    	; 0x704 <malloc+0x128>
 67c:	fe 01       	movw	r30, r28
 67e:	e2 0f       	add	r30, r18
 680:	f3 1f       	adc	r31, r19
 682:	81 93       	st	Z+, r24
 684:	91 93       	st	Z+, r25
 686:	22 50       	subi	r18, 0x02	; 2
 688:	31 09       	sbc	r19, r1
 68a:	39 83       	std	Y+1, r19	; 0x01
 68c:	28 83       	st	Y, r18
 68e:	3a c0       	rjmp	.+116    	; 0x704 <malloc+0x128>
 690:	20 91 58 01 	lds	r18, 0x0158
 694:	30 91 59 01 	lds	r19, 0x0159
 698:	23 2b       	or	r18, r19
 69a:	41 f4       	brne	.+16     	; 0x6ac <malloc+0xd0>
 69c:	20 91 02 01 	lds	r18, 0x0102
 6a0:	30 91 03 01 	lds	r19, 0x0103
 6a4:	30 93 59 01 	sts	0x0159, r19
 6a8:	20 93 58 01 	sts	0x0158, r18
 6ac:	20 91 00 01 	lds	r18, 0x0100
 6b0:	30 91 01 01 	lds	r19, 0x0101
 6b4:	21 15       	cp	r18, r1
 6b6:	31 05       	cpc	r19, r1
 6b8:	41 f4       	brne	.+16     	; 0x6ca <malloc+0xee>
 6ba:	2d b7       	in	r18, 0x3d	; 61
 6bc:	3e b7       	in	r19, 0x3e	; 62
 6be:	40 91 04 01 	lds	r20, 0x0104
 6c2:	50 91 05 01 	lds	r21, 0x0105
 6c6:	24 1b       	sub	r18, r20
 6c8:	35 0b       	sbc	r19, r21
 6ca:	e0 91 58 01 	lds	r30, 0x0158
 6ce:	f0 91 59 01 	lds	r31, 0x0159
 6d2:	e2 17       	cp	r30, r18
 6d4:	f3 07       	cpc	r31, r19
 6d6:	a0 f4       	brcc	.+40     	; 0x700 <malloc+0x124>
 6d8:	2e 1b       	sub	r18, r30
 6da:	3f 0b       	sbc	r19, r31
 6dc:	28 17       	cp	r18, r24
 6de:	39 07       	cpc	r19, r25
 6e0:	78 f0       	brcs	.+30     	; 0x700 <malloc+0x124>
 6e2:	ac 01       	movw	r20, r24
 6e4:	4e 5f       	subi	r20, 0xFE	; 254
 6e6:	5f 4f       	sbci	r21, 0xFF	; 255
 6e8:	24 17       	cp	r18, r20
 6ea:	35 07       	cpc	r19, r21
 6ec:	48 f0       	brcs	.+18     	; 0x700 <malloc+0x124>
 6ee:	4e 0f       	add	r20, r30
 6f0:	5f 1f       	adc	r21, r31
 6f2:	50 93 59 01 	sts	0x0159, r21
 6f6:	40 93 58 01 	sts	0x0158, r20
 6fa:	81 93       	st	Z+, r24
 6fc:	91 93       	st	Z+, r25
 6fe:	02 c0       	rjmp	.+4      	; 0x704 <malloc+0x128>
 700:	e0 e0       	ldi	r30, 0x00	; 0
 702:	f0 e0       	ldi	r31, 0x00	; 0
 704:	cf 01       	movw	r24, r30
 706:	df 91       	pop	r29
 708:	cf 91       	pop	r28
 70a:	08 95       	ret

0000070c <free>:
 70c:	cf 93       	push	r28
 70e:	df 93       	push	r29
 710:	00 97       	sbiw	r24, 0x00	; 0
 712:	09 f4       	brne	.+2      	; 0x716 <free+0xa>
 714:	87 c0       	rjmp	.+270    	; 0x824 <free+0x118>
 716:	fc 01       	movw	r30, r24
 718:	32 97       	sbiw	r30, 0x02	; 2
 71a:	13 82       	std	Z+3, r1	; 0x03
 71c:	12 82       	std	Z+2, r1	; 0x02
 71e:	c0 91 5a 01 	lds	r28, 0x015A
 722:	d0 91 5b 01 	lds	r29, 0x015B
 726:	20 97       	sbiw	r28, 0x00	; 0
 728:	81 f4       	brne	.+32     	; 0x74a <free+0x3e>
 72a:	20 81       	ld	r18, Z
 72c:	31 81       	ldd	r19, Z+1	; 0x01
 72e:	28 0f       	add	r18, r24
 730:	39 1f       	adc	r19, r25
 732:	80 91 58 01 	lds	r24, 0x0158
 736:	90 91 59 01 	lds	r25, 0x0159
 73a:	82 17       	cp	r24, r18
 73c:	93 07       	cpc	r25, r19
 73e:	79 f5       	brne	.+94     	; 0x79e <free+0x92>
 740:	f0 93 59 01 	sts	0x0159, r31
 744:	e0 93 58 01 	sts	0x0158, r30
 748:	6d c0       	rjmp	.+218    	; 0x824 <free+0x118>
 74a:	de 01       	movw	r26, r28
 74c:	20 e0       	ldi	r18, 0x00	; 0
 74e:	30 e0       	ldi	r19, 0x00	; 0
 750:	ae 17       	cp	r26, r30
 752:	bf 07       	cpc	r27, r31
 754:	50 f4       	brcc	.+20     	; 0x76a <free+0x5e>
 756:	12 96       	adiw	r26, 0x02	; 2
 758:	4d 91       	ld	r20, X+
 75a:	5c 91       	ld	r21, X
 75c:	13 97       	sbiw	r26, 0x03	; 3
 75e:	9d 01       	movw	r18, r26
 760:	41 15       	cp	r20, r1
 762:	51 05       	cpc	r21, r1
 764:	09 f1       	breq	.+66     	; 0x7a8 <free+0x9c>
 766:	da 01       	movw	r26, r20
 768:	f3 cf       	rjmp	.-26     	; 0x750 <free+0x44>
 76a:	b3 83       	std	Z+3, r27	; 0x03
 76c:	a2 83       	std	Z+2, r26	; 0x02
 76e:	40 81       	ld	r20, Z
 770:	51 81       	ldd	r21, Z+1	; 0x01
 772:	84 0f       	add	r24, r20
 774:	95 1f       	adc	r25, r21
 776:	8a 17       	cp	r24, r26
 778:	9b 07       	cpc	r25, r27
 77a:	71 f4       	brne	.+28     	; 0x798 <free+0x8c>
 77c:	8d 91       	ld	r24, X+
 77e:	9c 91       	ld	r25, X
 780:	11 97       	sbiw	r26, 0x01	; 1
 782:	84 0f       	add	r24, r20
 784:	95 1f       	adc	r25, r21
 786:	02 96       	adiw	r24, 0x02	; 2
 788:	91 83       	std	Z+1, r25	; 0x01
 78a:	80 83       	st	Z, r24
 78c:	12 96       	adiw	r26, 0x02	; 2
 78e:	8d 91       	ld	r24, X+
 790:	9c 91       	ld	r25, X
 792:	13 97       	sbiw	r26, 0x03	; 3
 794:	93 83       	std	Z+3, r25	; 0x03
 796:	82 83       	std	Z+2, r24	; 0x02
 798:	21 15       	cp	r18, r1
 79a:	31 05       	cpc	r19, r1
 79c:	29 f4       	brne	.+10     	; 0x7a8 <free+0x9c>
 79e:	f0 93 5b 01 	sts	0x015B, r31
 7a2:	e0 93 5a 01 	sts	0x015A, r30
 7a6:	3e c0       	rjmp	.+124    	; 0x824 <free+0x118>
 7a8:	d9 01       	movw	r26, r18
 7aa:	13 96       	adiw	r26, 0x03	; 3
 7ac:	fc 93       	st	X, r31
 7ae:	ee 93       	st	-X, r30
 7b0:	12 97       	sbiw	r26, 0x02	; 2
 7b2:	4d 91       	ld	r20, X+
 7b4:	5d 91       	ld	r21, X+
 7b6:	a4 0f       	add	r26, r20
 7b8:	b5 1f       	adc	r27, r21
 7ba:	ea 17       	cp	r30, r26
 7bc:	fb 07       	cpc	r31, r27
 7be:	79 f4       	brne	.+30     	; 0x7de <free+0xd2>
 7c0:	80 81       	ld	r24, Z
 7c2:	91 81       	ldd	r25, Z+1	; 0x01
 7c4:	84 0f       	add	r24, r20
 7c6:	95 1f       	adc	r25, r21
 7c8:	02 96       	adiw	r24, 0x02	; 2
 7ca:	d9 01       	movw	r26, r18
 7cc:	11 96       	adiw	r26, 0x01	; 1
 7ce:	9c 93       	st	X, r25
 7d0:	8e 93       	st	-X, r24
 7d2:	82 81       	ldd	r24, Z+2	; 0x02
 7d4:	93 81       	ldd	r25, Z+3	; 0x03
 7d6:	13 96       	adiw	r26, 0x03	; 3
 7d8:	9c 93       	st	X, r25
 7da:	8e 93       	st	-X, r24
 7dc:	12 97       	sbiw	r26, 0x02	; 2
 7de:	e0 e0       	ldi	r30, 0x00	; 0
 7e0:	f0 e0       	ldi	r31, 0x00	; 0
 7e2:	8a 81       	ldd	r24, Y+2	; 0x02
 7e4:	9b 81       	ldd	r25, Y+3	; 0x03
 7e6:	00 97       	sbiw	r24, 0x00	; 0
 7e8:	19 f0       	breq	.+6      	; 0x7f0 <free+0xe4>
 7ea:	fe 01       	movw	r30, r28
 7ec:	ec 01       	movw	r28, r24
 7ee:	f9 cf       	rjmp	.-14     	; 0x7e2 <free+0xd6>
 7f0:	ce 01       	movw	r24, r28
 7f2:	02 96       	adiw	r24, 0x02	; 2
 7f4:	28 81       	ld	r18, Y
 7f6:	39 81       	ldd	r19, Y+1	; 0x01
 7f8:	82 0f       	add	r24, r18
 7fa:	93 1f       	adc	r25, r19
 7fc:	20 91 58 01 	lds	r18, 0x0158
 800:	30 91 59 01 	lds	r19, 0x0159
 804:	28 17       	cp	r18, r24
 806:	39 07       	cpc	r19, r25
 808:	69 f4       	brne	.+26     	; 0x824 <free+0x118>
 80a:	30 97       	sbiw	r30, 0x00	; 0
 80c:	29 f4       	brne	.+10     	; 0x818 <free+0x10c>
 80e:	10 92 5b 01 	sts	0x015B, r1
 812:	10 92 5a 01 	sts	0x015A, r1
 816:	02 c0       	rjmp	.+4      	; 0x81c <free+0x110>
 818:	13 82       	std	Z+3, r1	; 0x03
 81a:	12 82       	std	Z+2, r1	; 0x02
 81c:	d0 93 59 01 	sts	0x0159, r29
 820:	c0 93 58 01 	sts	0x0158, r28
 824:	df 91       	pop	r29
 826:	cf 91       	pop	r28
 828:	08 95       	ret

0000082a <fdevopen>:
 82a:	0f 93       	push	r16
 82c:	1f 93       	push	r17
 82e:	cf 93       	push	r28
 830:	df 93       	push	r29
 832:	ec 01       	movw	r28, r24
 834:	8b 01       	movw	r16, r22
 836:	00 97       	sbiw	r24, 0x00	; 0
 838:	31 f4       	brne	.+12     	; 0x846 <fdevopen+0x1c>
 83a:	61 15       	cp	r22, r1
 83c:	71 05       	cpc	r23, r1
 83e:	19 f4       	brne	.+6      	; 0x846 <fdevopen+0x1c>
 840:	80 e0       	ldi	r24, 0x00	; 0
 842:	90 e0       	ldi	r25, 0x00	; 0
 844:	38 c0       	rjmp	.+112    	; 0x8b6 <fdevopen+0x8c>
 846:	6e e0       	ldi	r22, 0x0E	; 14
 848:	70 e0       	ldi	r23, 0x00	; 0
 84a:	81 e0       	ldi	r24, 0x01	; 1
 84c:	90 e0       	ldi	r25, 0x00	; 0
 84e:	0e 94 8d 04 	call	0x91a	; 0x91a <calloc>
 852:	fc 01       	movw	r30, r24
 854:	00 97       	sbiw	r24, 0x00	; 0
 856:	a1 f3       	breq	.-24     	; 0x840 <fdevopen+0x16>
 858:	80 e8       	ldi	r24, 0x80	; 128
 85a:	83 83       	std	Z+3, r24	; 0x03
 85c:	01 15       	cp	r16, r1
 85e:	11 05       	cpc	r17, r1
 860:	71 f0       	breq	.+28     	; 0x87e <fdevopen+0x54>
 862:	13 87       	std	Z+11, r17	; 0x0b
 864:	02 87       	std	Z+10, r16	; 0x0a
 866:	81 e8       	ldi	r24, 0x81	; 129
 868:	83 83       	std	Z+3, r24	; 0x03
 86a:	80 91 5c 01 	lds	r24, 0x015C
 86e:	90 91 5d 01 	lds	r25, 0x015D
 872:	89 2b       	or	r24, r25
 874:	21 f4       	brne	.+8      	; 0x87e <fdevopen+0x54>
 876:	f0 93 5d 01 	sts	0x015D, r31
 87a:	e0 93 5c 01 	sts	0x015C, r30
 87e:	20 97       	sbiw	r28, 0x00	; 0
 880:	c9 f0       	breq	.+50     	; 0x8b4 <fdevopen+0x8a>
 882:	d1 87       	std	Z+9, r29	; 0x09
 884:	c0 87       	std	Z+8, r28	; 0x08
 886:	83 81       	ldd	r24, Z+3	; 0x03
 888:	82 60       	ori	r24, 0x02	; 2
 88a:	83 83       	std	Z+3, r24	; 0x03
 88c:	80 91 5e 01 	lds	r24, 0x015E
 890:	90 91 5f 01 	lds	r25, 0x015F
 894:	89 2b       	or	r24, r25
 896:	71 f4       	brne	.+28     	; 0x8b4 <fdevopen+0x8a>
 898:	f0 93 5f 01 	sts	0x015F, r31
 89c:	e0 93 5e 01 	sts	0x015E, r30
 8a0:	80 91 60 01 	lds	r24, 0x0160
 8a4:	90 91 61 01 	lds	r25, 0x0161
 8a8:	89 2b       	or	r24, r25
 8aa:	21 f4       	brne	.+8      	; 0x8b4 <fdevopen+0x8a>
 8ac:	f0 93 61 01 	sts	0x0161, r31
 8b0:	e0 93 60 01 	sts	0x0160, r30
 8b4:	cf 01       	movw	r24, r30
 8b6:	df 91       	pop	r29
 8b8:	cf 91       	pop	r28
 8ba:	1f 91       	pop	r17
 8bc:	0f 91       	pop	r16
 8be:	08 95       	ret

000008c0 <puts>:
 8c0:	0f 93       	push	r16
 8c2:	1f 93       	push	r17
 8c4:	cf 93       	push	r28
 8c6:	df 93       	push	r29
 8c8:	e0 91 5e 01 	lds	r30, 0x015E
 8cc:	f0 91 5f 01 	lds	r31, 0x015F
 8d0:	23 81       	ldd	r18, Z+3	; 0x03
 8d2:	21 ff       	sbrs	r18, 1
 8d4:	1b c0       	rjmp	.+54     	; 0x90c <puts+0x4c>
 8d6:	ec 01       	movw	r28, r24
 8d8:	00 e0       	ldi	r16, 0x00	; 0
 8da:	10 e0       	ldi	r17, 0x00	; 0
 8dc:	89 91       	ld	r24, Y+
 8de:	60 91 5e 01 	lds	r22, 0x015E
 8e2:	70 91 5f 01 	lds	r23, 0x015F
 8e6:	db 01       	movw	r26, r22
 8e8:	18 96       	adiw	r26, 0x08	; 8
 8ea:	ed 91       	ld	r30, X+
 8ec:	fc 91       	ld	r31, X
 8ee:	19 97       	sbiw	r26, 0x09	; 9
 8f0:	88 23       	and	r24, r24
 8f2:	31 f0       	breq	.+12     	; 0x900 <puts+0x40>
 8f4:	09 95       	icall
 8f6:	89 2b       	or	r24, r25
 8f8:	89 f3       	breq	.-30     	; 0x8dc <puts+0x1c>
 8fa:	0f ef       	ldi	r16, 0xFF	; 255
 8fc:	1f ef       	ldi	r17, 0xFF	; 255
 8fe:	ee cf       	rjmp	.-36     	; 0x8dc <puts+0x1c>
 900:	8a e0       	ldi	r24, 0x0A	; 10
 902:	09 95       	icall
 904:	89 2b       	or	r24, r25
 906:	11 f4       	brne	.+4      	; 0x90c <puts+0x4c>
 908:	c8 01       	movw	r24, r16
 90a:	02 c0       	rjmp	.+4      	; 0x910 <puts+0x50>
 90c:	8f ef       	ldi	r24, 0xFF	; 255
 90e:	9f ef       	ldi	r25, 0xFF	; 255
 910:	df 91       	pop	r29
 912:	cf 91       	pop	r28
 914:	1f 91       	pop	r17
 916:	0f 91       	pop	r16
 918:	08 95       	ret

0000091a <calloc>:
 91a:	0f 93       	push	r16
 91c:	1f 93       	push	r17
 91e:	cf 93       	push	r28
 920:	df 93       	push	r29
 922:	86 9f       	mul	r24, r22
 924:	80 01       	movw	r16, r0
 926:	87 9f       	mul	r24, r23
 928:	10 0d       	add	r17, r0
 92a:	96 9f       	mul	r25, r22
 92c:	10 0d       	add	r17, r0
 92e:	11 24       	eor	r1, r1
 930:	c8 01       	movw	r24, r16
 932:	0e 94 ee 02 	call	0x5dc	; 0x5dc <malloc>
 936:	ec 01       	movw	r28, r24
 938:	00 97       	sbiw	r24, 0x00	; 0
 93a:	29 f0       	breq	.+10     	; 0x946 <calloc+0x2c>
 93c:	a8 01       	movw	r20, r16
 93e:	60 e0       	ldi	r22, 0x00	; 0
 940:	70 e0       	ldi	r23, 0x00	; 0
 942:	0e 94 a9 04 	call	0x952	; 0x952 <memset>
 946:	ce 01       	movw	r24, r28
 948:	df 91       	pop	r29
 94a:	cf 91       	pop	r28
 94c:	1f 91       	pop	r17
 94e:	0f 91       	pop	r16
 950:	08 95       	ret

00000952 <memset>:
 952:	dc 01       	movw	r26, r24
 954:	01 c0       	rjmp	.+2      	; 0x958 <memset+0x6>
 956:	6d 93       	st	X+, r22
 958:	41 50       	subi	r20, 0x01	; 1
 95a:	50 40       	sbci	r21, 0x00	; 0
 95c:	e0 f7       	brcc	.-8      	; 0x956 <memset+0x4>
 95e:	08 95       	ret

00000960 <_exit>:
 960:	f8 94       	cli

00000962 <__stop_program>:
 962:	ff cf       	rjmp	.-2      	; 0x962 <__stop_program>
